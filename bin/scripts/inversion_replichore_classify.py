#!/usr/bin/env python3

''' imports '''

import os
import pandas as pd
pd.options.mode.chained_assignment = None  # default='warn'
import numpy as np
import argparse
from collections import Counter
import numpy as np

''' fetch arguments from the command line '''

parser = argparse.ArgumentParser(description='inversion_replichore_classify')
parser.add_argument('--folder', help='name of the folder with the <clone>_inversions.csv files generated by classify_deletions.py')
parser.add_argument('--oridif', help='name of the csv file with the coords of oric and dif of clones, generated by replichore_arms_analyse.py')
parser.add_argument('--output', help='name of output csv')
parser.add_argument('--data', help='data.csv file with paths to ancestors')
parser.add_argument('--verbose', '-v', action='store_true', help='Enable verbose mode')

def get_csv_names(folder):

    ''' return a list of all the <clone>_inversion.csv files in the folder '''

    os.chdir(folder)
    csv_names = []
    for entry in os.scandir():
        if entry.is_file() and entry.name.endswith("inversion.csv") and len(entry.name) > len("inversion.csv"):
            csv_names.append(entry.name)
    return csv_names

def classify_inversion(file,df_oridif,assembly_to_ancestor_dict):

    ''' accept the name of a <clone>_inversion.csv file and the oridif table and return a dict with the number of each type of inversion '''

    df=pd.read_csv(file)
    df['classification']=['']*(len(df)) # stores the classification of the inversion
    df['length']=['']*(len(df)) # stores the length of the inversion
    df['symmetry_stat']=['']*(len(df)) # stores the symmetry statistic, for an inter-replichore inversion
    df['symmetry_stat_log']=['']*(len(df)) # stores the symmetry statistic, for an inter-replichore inversion
    df['symmetry_ratio']=['']*(len(df)) # stores the symmetry number
    df['symmetry_ratio_length']=['']*(len(df)) # stores the length of the inversion. this double checks that I have the sizes of the arms right. This should match the inversion length
    df['symmetry_percent']=['']*(len(df)) # stores big amr/ total inv length * 100
    clone=file.replace('_inversion.csv','') # get the name of the clone

    #index_of_clone = df_oridif[df_oridif['clone'] == ancestor].index[0] # row index of ancestor in the oridif dataframe, to fetch the coords of the ori and dif
    ancestor = assembly_to_ancestor_dict[clone] # use this dict to fetch the ancestor of the clone
    index_of_clone = df_oridif[df_oridif['clone'] == ancestor].index[0]
    ori=int(df_oridif.loc[index_of_clone,'ori'])
    dif=int(df_oridif.loc[index_of_clone,'dif'])
    length=int(df_oridif.loc[index_of_clone,'length'])

    clone_name=file.replace('_inversion.csv','')
    summary_dict={'clone':clone_name, 'total_inversions':len(df), 'across_ori':0, 'across_dif':0, 'total_inter_replichore':0, 'total_intra_replichore':0} # store output

    row_idx=0 # index counter for the index of lines of df
    for row_idx in range(len(df)):

        start_inversion=int(df.loc[row_idx,'ref_start'])
        stop_inversion=int(df.loc[row_idx,'ref_stop'])
        inversion_length=int(stop_inversion)-int(start_inversion)

        # check to see if the inversion is less than half the length of the genome. If yes, then the inversion can span either the ori or the dif, but not both.

        if inversion_length <= 0.5*length:

            df.loc[row_idx,'length']=inversion_length

            if start_inversion < ori and ori < stop_inversion: # an inversion across the origin
                summary_dict['across_ori']+=1
                summary_dict['total_inter_replichore']+=1
                df.loc[row_idx,'classification']="across_ori"

                # compute symmetry statistic
                arm1=abs(start_inversion-ori)
                arm2=abs(stop_inversion-ori)
                #print(f"arm 1 {arm1} and arm2 {arm2} for inversion {inversion_length} and sum is {(arm1+arm2)}")
                df.loc[row_idx,'symmetry_stat']=(arm1-arm2)**2
                df.loc[row_idx,'symmetry_ratio_length']=arm1+arm2
                df.loc[row_idx,'symmetry_ratio']=(min(arm1,arm2))/(max(arm1,arm2)) # ratio of short arm to long arm
                df.loc[row_idx,'symmetry_percent']=((max(arm1,arm2))/inversion_length)*100

            elif start_inversion < dif and dif < stop_inversion: # an inversion across the terminus
                summary_dict['across_dif']+=1
                summary_dict['total_inter_replichore']+=1
                df.loc[row_idx,'classification']="across_dif"

                # compute symmetry statistic
                arm1=abs(start_inversion-dif)
                arm2=abs(stop_inversion-dif)
                #print(f"arm 1 {arm1} and arm2 {arm2} for inversion {inversion_length} and sum is {(arm1+arm2)}")
                df.loc[row_idx,'symmetry_stat']=(arm1-arm2)**2
                df.loc[row_idx,'symmetry_ratio']=(min(arm1,arm2))/(max(arm1,arm2)) # ratio of short arm to long arm
                df.loc[row_idx,'symmetry_ratio_length']=arm1+arm2
                df.loc[row_idx,'symmetry_percent']=((max(arm1,arm2))/inversion_length)*100

            else:
                summary_dict['total_intra_replichore']+=1
                df.loc[row_idx,'classification']="intra_replichore"
                df.loc[row_idx,'symmetry_stat']=0
                df.loc[row_idx,'symmetry_ratio']=0
                df.loc[row_idx,'symmetry_ratio_length']=0
                df.loc[row_idx,'symmetry_percent']=0

        # check to see if the inversion is greater than half the length of the genome

        if inversion_length > 0.5*length:

            # split this inversion into two sub-inversions which represent the complementary inversion, which is smaller.
            # By definition, these sub-inversions cannot span both the ori and dif, only one or none

            inv1_start=0 # the first sub inversion starts at the start of the assembly and ends at the start of the "big" inversion
            inv1_stop=start_inversion
            inv2_start=stop_inversion # the second sub inversion starts at the end of the "big inversion" and continue till the end of the genome assembly
            inv2_stop=length
            inversion_length=(inv1_stop-inv1_start)+(inv2_stop-inv2_start) # length of the complementary inversion

            df.loc[row_idx,'length']=inversion_length

            if (inv1_start < ori and ori < inv1_stop): # one of the sub inversions spans the ori i.e this is across_ori

                summary_dict['across_ori']+=1
                summary_dict['total_inter_replichore']+=1
                df.loc[row_idx,'classification']="complementary_across_ori"

                arm1=abs(inv1_stop-ori)
                arm2=abs((dif-inv1_start)+(inv2_stop-inv1_start))
                print(f"arm 1 {arm1} and arm2 {arm2} for inversion {inversion_length} and sum is {(arm1+arm2)}")

                df.loc[row_idx,'symmetry_stat']=(arm1-arm2)**2
                df.loc[row_idx,'symmetry_ratio']=(min(arm1,arm2))/(max(arm1,arm2)) # ratio of short arm to long arm
                df.loc[row_idx,'symmetry_ratio_length']=arm1+arm2
                df.loc[row_idx,'symmetry_percent']=((max(arm1,arm2))/inversion_length)*100

            elif (inv2_start < ori and ori < inv2_stop): # one of the sub inversions spans the ori i.e this is across_ori

                summary_dict['across_ori']+=1
                summary_dict['total_inter_replichore']+=1
                df.loc[row_idx,'classification']="complementary_across_ori"

                arm1=abs((inv1_stop-inv1_start)+(inv2_stop-ori))
                arm2=abs(ori-inv2_start)
                #print(f"inv1_start is {inv1_start}, inv1_stop is {inv1_stop}, ori is {ori}, inv2_start is {inv2_start} inv2_stop is {inv2_stop}")
                #print(f"arm 1 {arm1} and arm2 {arm2} for inversion {inversion_length} and sum is {(arm1+arm2)}")

                df.loc[row_idx,'symmetry_stat']=(arm1-arm2)**2
                df.loc[row_idx,'symmetry_ratio']=(min(arm1,arm2))/(max(arm1,arm2)) # ratio of short arm to long arm
                df.loc[row_idx,'symmetry_ratio_length']=arm1+arm2
                df.loc[row_idx,'symmetry_percent']=((max(arm1,arm2))/inversion_length)*100

            elif (inv1_start < dif and dif < inv1_stop): # one of the sub inversions spans the dif i.e this is across_dif

                summary_dict['across_dif']+=1
                summary_dict['total_inter_replichore']+=1
                df.loc[row_idx,'classification']="complementary_across_dif"

                arm1=abs(inv1_stop-dif)
                arm2=abs((dif-inv1_start)+(inv2_stop-inv1_start))
                #print(f"arm 1 {arm1} and arm2 {arm2} for inversion {inversion_length} and sum is {(arm1+arm2)}")

                df.loc[row_idx,'symmetry_stat']=(arm1-arm2)**2
                df.loc[row_idx,'symmetry_ratio']=(min(arm1,arm2))/(max(arm1,arm2)) # ratio of short arm to long arm
                df.loc[row_idx,'symmetry_ratio_length']=arm1+arm2
                df.loc[row_idx,'symmetry_percent']=((max(arm1,arm2))/inversion_length)*100

            elif (inv2_start < dif and dif < inv2_stop): # one of the sub inversions spans the dif i.e this is across_dif
                summary_dict['across_dif']+=1
                summary_dict['total_inter_replichore']+=1
                df.loc[row_idx,'classification']="complementary_across_dif"

                arm1=abs((inv1_stop-inv1_start)+(inv2_stop-dif))
                arm2=abs(dif-inv2_start)
                #print(f"arm 1 {arm1} and arm2 {arm2} for inversion {inversion_length} and sum is {(arm1+arm2)}")

                df.loc[row_idx,'symmetry_stat']=(arm1-arm2)**2
                df.loc[row_idx,'symmetry_ratio']=(min(arm1,arm2))/(max(arm1,arm2)) # ratio of short arm to long arm
                df.loc[row_idx,'symmetry_ratio_length']=arm1+arm2
                df.loc[row_idx,'symmetry_percent']=((max(arm1,arm2))/inversion_length)*100

            else:
                summary_dict['total_intra_replichore']+=1
                df.loc[row_idx,'classification']="complementary_intra_replichore"
                df.loc[row_idx,'symmetry_stat']=0
                df.loc[row_idx,'symmetry_ratio']=0
                df.loc[row_idx,'symmetry_ratio_length']=0
                df.loc[row_idx,'symmetry_percent']=0

    df['symmetry_stat_log'] = np.log10(df['symmetry_stat'].astype(float).replace(0, 1))
    return summary_dict, df

def generate_inversion_table(df,clone): # a summary table of all inversions, their type, length across a given clone

    df_temp = pd.DataFrame(columns=['clone','classification','length','mechanism','symmetry_ratio','symmetry_ratio_length','symmetry_percent'])
    df_temp["classification"] = df["classification"]
    df_temp["length"] = df["length"]
    df_temp["mechanism"] = df["Mechanism"]
    df_temp["symmetry_ratio"]=df["symmetry_ratio"]
    df_temp["symmetry_ratio_length"]=df["symmetry_ratio_length"]
    df_temp['symmetry_percent']=df['symmetry_percent']
    df_temp["clone"] = [clone]*len(df_temp)
    df_temp=df_temp.reset_index(drop=True)
    return df_temp

def main(folder,output,oridif,data):

    df_data = pd.read_csv(data)

    # these dictionaries map assembly to its path and assembly to its ancestor
    #assembly_to_path_dict = dict(zip(df_data['assembly'], df_data['assembly_path']))
    assembly_to_ancestor_dict = dict(zip(df_data['assembly'], df_data['ancestor']))

    df_oridif=pd.read_csv(oridif)
    csv_names=get_csv_names(folder)
    summary_list=[]
    df_table = pd.DataFrame()
    for file in csv_names:
        print (file)
        summary_dict, df =classify_inversion(file, df_oridif,assembly_to_ancestor_dict)
        clone=file.replace('_inversion.csv','') # get the name of the clone
        df_temp = generate_inversion_table(df,clone)
        df_table = pd.concat([df_table,df_temp], ignore_index=True)
        new_filename = f"{clone}_inversion_classification.csv" #write out the inversions and the replichore classification to a new file so snakemake doesnt complain about two rules generating the same output
        df.to_csv(new_filename, index=False,float_format='%.0f')
        summary_list.append(summary_dict)
    df=pd.DataFrame(summary_list)
    df.to_csv(output, index=False,float_format='%.0f')
    output=output.replace('.csv','')
    output=output+"_long.csv"
    df_table.to_csv(output, index=False,float_format='%.0f')


if __name__ == '__main__':
    args = parser.parse_args()
    main(args.folder,args.output,args.oridif,args.data)
